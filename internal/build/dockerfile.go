// Package build provides Dockerfile generation for detected projects.
package build

import (
	"bytes"
	"os"
	"runtime"
	"strings"
	"text/template"

	det "mitl/internal/detector"
)

// DockerfileGenerator creates optimized Dockerfiles based on project detection
type DockerfileGenerator struct {
	Detector *det.ProjectDetector
	Platform string // linux/amd64, linux/arm64
	BuildKit bool   // Use BuildKit features?
}

// LegacyDockerfileGenerator wraps DockerfileGenerator to preserve legacy API
// This maintains compatibility with existing code during the refactoring
type LegacyDockerfileGenerator struct {
	Detector *det.ProjectDetector
	inner    *DockerfileGenerator
}

// NewDockerfileGenerator creates a generator instance
func NewDockerfileGenerator(detector *det.ProjectDetector) *DockerfileGenerator {
	return &DockerfileGenerator{
		Detector: detector,
		Platform: detectOptimalPlatform(),
		BuildKit: true,
	}
}

// NewLegacyDockerfileGenerator creates a wrapper around internal generator
// for backward compatibility with main package types
func NewLegacyDockerfileGenerator(detector *det.ProjectDetector) *LegacyDockerfileGenerator {
	g := &LegacyDockerfileGenerator{Detector: detector}
	// Bridge: ensure internal detector is used
	var in *det.ProjectDetector
	if detector != nil {
		// create a fresh internal detector and copy over key fields
		in = det.NewProjectDetector(detector.Root)
		in.Type = detector.Type
		in.Languages = toInternalLanguages(detector.Languages)
		in.Framework = detector.Framework
		in.Version = detector.Version
		in.Dependencies = toInternalDependencies(detector.Dependencies)
		in.Metadata = detector.Metadata
	}
	g.inner = NewDockerfileGenerator(in)
	return g
}

// Generate proxies to internal generator
func (dg *LegacyDockerfileGenerator) Generate() (string, error) { return dg.inner.Generate() }

// Lowercase helpers used by tests
func (dg *LegacyDockerfileGenerator) generateGo() (string, error) { return dg.inner.GenerateGo() }

func (dg *LegacyDockerfileGenerator) generatePython() (string, error) {
	return dg.inner.GeneratePython()
}

func (dg *LegacyDockerfileGenerator) generateGeneric() (string, error) {
	return dg.inner.GenerateGeneric()
}

func (dg *LegacyDockerfileGenerator) OptimizationHints() []string {
	return dg.inner.OptimizationHints()
}

// Conversions between main types and internal/detector types
func toInternalLanguages(xs []det.Language) []det.Language {
	out := make([]det.Language, 0, len(xs))
	for _, l := range xs {
		out = append(out, det.Language{Name: l.Name, Version: l.Version, Primary: l.Primary})
	}
	return out
}

func toInternalDependencies(d det.Dependencies) det.Dependencies {
	return det.Dependencies{
		PHP: det.PHPDependencies{
			Version:     d.PHP.Version,
			Extensions:  append([]string(nil), d.PHP.Extensions...),
			Composer:    d.PHP.Composer,
			ComposerVer: d.PHP.ComposerVer,
			IniSettings: d.PHP.IniSettings,
		},
		Node: det.NodeDependencies{
			Version:        d.Node.Version,
			PackageManager: d.Node.PackageManager,
			GlobalPackages: append([]string(nil), d.Node.GlobalPackages...),
			BuildTools:     d.Node.BuildTools,
		},
		Python: det.PythonDependencies{
			Version:    d.Python.Version,
			UsesPoetry: d.Python.UsesPoetry,
			UsesPipenv: d.Python.UsesPipenv,
			UsesVenv:   d.Python.UsesVenv,
			SystemDeps: append([]string(nil), d.Python.SystemDeps...),
		},
		System: append([]string(nil), d.System...),
	}
}

// Generate creates the complete Dockerfile
func (dg *DockerfileGenerator) Generate() (string, error) {
	switch dg.Detector.Type {
	case det.TypePHPLaravel:
		return dg.GenerateLaravel()
	case det.TypeNodeNext:
		fallthrough
	case det.TypeNodeNuxt:
		return dg.GenerateNode()
	case det.TypeNodeGeneric:
		return dg.GenerateNode()
	case det.TypeGoModule:
		return dg.GenerateGo()
	case det.TypePythonDjango, det.TypePythonFlask, det.TypePythonGeneric:
		return dg.GeneratePython()
	default:
		return dg.GenerateGeneric()
	}
}

// GenerateLaravel creates an opinionated Laravel Dockerfile (alpine-based)
func (dg *DockerfileGenerator) GenerateLaravel() (string, error) {
	tmpl := `# syntax=docker/dockerfile:1.4
# Auto-generated by Mitl for Laravel project
# Optimized for: PHP {{.PHPVersion}}, {{.Platform}}

# Stage 1: Composer dependencies
FROM composer:2 AS composer-deps
WORKDIR /app

COPY composer.json composer.lock* ./
RUN --mount=type=cache,target=/root/.composer \
    composer install --no-dev --no-scripts --no-interaction --prefer-dist --no-progress

COPY . .
RUN composer dump-autoload --optimize --classmap-authoritative

{{if .HasNodeDeps}}
# Stage 2: Node dependencies
FROM node:{{.NodeVersion}}-alpine AS node-deps
WORKDIR /app
COPY package*.json ./
{{if eq .PackageManager "pnpm"}}COPY pnpm-lock.yaml* ./{{end}}
{{if eq .PackageManager "yarn"}}COPY yarn.lock* ./{{end}}
RUN --mount=type=cache,target=/root/.npm \
    --mount=type=cache,target=/root/.pnpm-store \
    --mount=type=cache,target=/root/.yarn \
    {{.PackageManager}} {{if eq .PackageManager "npm"}}ci{{else}}install --frozen-lockfile{{end}}
COPY . .
RUN {{.PackageManager}} run build || echo "no build script"
{{end}}

# Stage 3: Final image
FROM php:{{.PHPVersion}}-fpm-alpine{{.AlpineVersion}}
WORKDIR /app

RUN --mount=type=cache,target=/var/cache/apk \
    apk add --no-cache git nginx supervisor {{.SystemPackages}} && \
    docker-php-ext-install -j$(nproc) {{.PHPExtensions}}

{{if .HasRedis}}RUN pecl install redis && docker-php-ext-enable redis{{end}}
{{if .HasImagick}}RUN apk add --no-cache imagemagick-dev && pecl install imagick && docker-php-ext-enable imagick{{end}}

COPY --from=composer-deps /app/vendor ./vendor
COPY . .
{{if .HasNodeDeps}}COPY --from=node-deps /app/public/build ./public/build{{end}}

EXPOSE 9000
CMD ["php-fpm"]
`
	data := dg.prepareTemplateData()
	var buf bytes.Buffer
	t := template.Must(template.New("dockerfile").Parse(tmpl))
	err := t.Execute(&buf, data)
	return buf.String(), err
}

// GenerateNode creates an optimized Node.js Dockerfile
func (dg *DockerfileGenerator) GenerateNode() (string, error) {
	tmpl := `# syntax=docker/dockerfile:1.4
# Auto-generated by Mitl for Node.js project
# Node: {{.NodeVersion}} PM: {{.PackageManager}}

FROM node:{{.NodeVersion}}-alpine AS deps
WORKDIR /app
COPY package*.json ./
COPY pnpm-lock.yaml* ./
RUN corepack enable && corepack prepare pnpm@latest --activate
RUN --mount=type=cache,target=/root/.npm \
    --mount=type=cache,target=/root/.local/share/pnpm/store \
    --mount=type=cache,target=/root/.yarn \
    pnpm install --frozen-lockfile || pnpm install

FROM node:{{.NodeVersion}}-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN corepack enable && corepack prepare pnpm@latest --activate
{{if .HasBuildScript}}RUN pnpm run build{{end}}

FROM node:{{.NodeVersion}}-alpine
WORKDIR /app
RUN apk add --no-cache dumb-init
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
COPY --chown=nodejs:nodejs --from=builder /app/{{if .HasBuildScript}}dist{{else}}.{{end}} ./
{{if not .HasBuildScript}}COPY --chown=nodejs:nodejs --from=deps /app/node_modules ./node_modules{{end}}
USER nodejs
EXPOSE {{.Port}}
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "{{.EntryPoint}}"]
`
	data := dg.prepareNodeData()
	var buf bytes.Buffer
	t := template.Must(template.New("dockerfile").Parse(tmpl))
	err := t.Execute(&buf, data)
	return buf.String(), err
}

// GenerateGo creates a Go multi-stage build Dockerfile
func (dg *DockerfileGenerator) GenerateGo() (string, error) {
	tmpl := `# syntax=docker/dockerfile:1.4
FROM golang:1-alpine AS build
WORKDIR /src
ENV GOTOOLCHAIN=auto
COPY go.mod .
RUN --mount=type=cache,target=/go/pkg/mod go mod download
COPY . .
RUN CGO_ENABLED=0 go build -o /out/app ./...

FROM alpine:3
WORKDIR /app
COPY --from=build /out/app /usr/local/bin/app
CMD ["/usr/local/bin/app"]
`
	var buf bytes.Buffer
	t := template.Must(template.New("dockerfile").Parse(tmpl))
	err := t.Execute(&buf, map[string]any{})
	return buf.String(), err
}

// GeneratePython creates a Python Dockerfile
func (dg *DockerfileGenerator) GeneratePython() (string, error) {
	tmpl := `# syntax=docker/dockerfile:1.4
FROM python:{{.PyVersion}}-alpine
WORKDIR /app
COPY requirements.txt* ./
RUN --mount=type=cache,target=/root/.cache/pip pip install -r requirements.txt || true
COPY . .
EXPOSE 8000
CMD ["python", "-m", "http.server", "8000"]
`
	var buf bytes.Buffer
	t := template.Must(template.New("dockerfile").Parse(tmpl))
	py := dg.Detector.Dependencies.Python.Version
	if py == "" {
		py = "3.11"
	}
	err := t.Execute(&buf, map[string]any{"PyVersion": py})
	return buf.String(), err
}

// GenerateGeneric creates a minimal Alpine Dockerfile
func (dg *DockerfileGenerator) GenerateGeneric() (string, error) {
	tmpl := `# syntax=docker/dockerfile:1.4
FROM alpine:3
WORKDIR /app
COPY . .
CMD ["/bin/sh"]
`
	var buf bytes.Buffer
	t := template.Must(template.New("dockerfile").Parse(tmpl))
	err := t.Execute(&buf, map[string]any{})
	return buf.String(), err
}

// prepareTemplateData creates data map for PHP-based templates
func (dg *DockerfileGenerator) prepareTemplateData() map[string]any {
	data := make(map[string]any)
	if dg.Detector.Dependencies.PHP.Version != "" {
		data["PHPVersion"] = dg.Detector.Dependencies.PHP.Version
		data["PHPExtensions"] = strings.Join(dg.Detector.Dependencies.PHP.Extensions, " ")
		data["HasRedis"] = det.ContainsString(dg.Detector.Dependencies.PHP.Extensions, "redis")
		data["HasImagick"] = det.ContainsString(dg.Detector.Dependencies.PHP.Extensions, "imagick")
	} else {
		data["PHPVersion"] = "8.3"
		data["PHPExtensions"] = "pdo pdo_mysql"
	}
	// Node presence
	if dg.Detector.Dependencies.Node.Version != "" {
		data["NodeVersion"] = dg.Detector.Dependencies.Node.Version
		data["PackageManager"] = dg.Detector.Dependencies.Node.PackageManager
		data["HasNodeDeps"] = true
	}
	data["Platform"] = dg.Platform
	data["AlpineVersion"] = dg.getAlpineVersion()
	data["SystemPackages"] = strings.Join(dg.Detector.Dependencies.System, " ")
	return data
}

// prepareNodeData creates data map for Node templates
func (dg *DockerfileGenerator) prepareNodeData() map[string]any {
	// Enforce pnpm for all Node projects
	pkg := "pnpm"
	entry := "index.js"
	port := "3000"
	hasBuild := false
	if m, ok := dg.Detector.Metadata["package.json"].(map[string]interface{}); ok {
		if scripts, ok := m["scripts"].(map[string]interface{}); ok {
			if _, ok := scripts["build"]; ok {
				hasBuild = true
			}
			if s, ok := scripts["start"].(string); ok && strings.Contains(s, "next") {
				entry = "server.js"
			}
		}
	}
	return map[string]any{
		"NodeVersion":    dg.Detector.Dependencies.Node.Version,
		"PackageManager": pkg,
		"HasBuildScript": hasBuild,
		"EntryPoint":     entry,
		"Port":           port,
	}
}

// OptimizationHints returns suggestions for the generated Dockerfile
func (dg *DockerfileGenerator) OptimizationHints() []string {
	hints := []string{}
	if dg.Detector.Type == det.TypePHPLaravel {
		hints = append(hints,
			"ðŸ’¡ Consider using Octane for 10x performance boost",
			"ðŸ’¡ Enable OPcache for 2-3x faster execution",
		)
	}
	if strings.HasPrefix(string(dg.Detector.Type), "node") {
		hints = append(hints, "ðŸ’¡ Using Alpine Linux for smaller image size")
	}
	return hints
}

// detectOptimalPlatform chooses a sane default platform string
func detectOptimalPlatform() string {
	if p := os.Getenv("MITL_PLATFORM"); p != "" {
		return p
	}
	if runtime.GOOS == "darwin" && runtime.GOARCH == "arm64" {
		return "linux/arm64"
	}
	return "linux/amd64"
}

// getAlpineVersion optionally returns an Alpine suffix (e.g. -3.20) for images
func (dg *DockerfileGenerator) getAlpineVersion() string {
	// Keep empty to use upstream default tag resolution
	return ""
}
